> # 回溯
>
> 回溯其实只是**利用递归暴力遍历dfs**，其解决的问题都可以抽象为**树形结构**(函数参数、终止条件和单层搜索)
>
> - 当探索到某一步时，发现原先选择并不优，就**退回到那一步重新选择**
>
> - 回溯法解决的都是在集合中递归查找子集，**集合的大小就构成了树的宽度，递归的深度构成的树的深度**。
>
> ![image-20230905174537254](img/image-20230905174537254.png)
>
> 
>
> 
>
> # 分治与递归
>
> 分治与递归自上而下的分割问题，自下而上的整合结果，但仅考虑子问题之间的关系!
>
> 具有以下特点：
>
>      　 1) 该问题可以分解为若干个规模较小的相同问题，即该问题具有**最优子结构性质。**
>           2) 该问题的规模**缩小**到一定的程度就可以**容易地解决**
>                   　 3) 利用该问题分解出的子问题的解**可以合并**为该问题的解；
>                        4) 该问题所分解出的**各个子问题是相互独立的**，即子问题之间不包含公共的子子问题。
>
> 
>
> 
>
> # 贪心
>
> 贪心法选择每一阶段的局部最优，从而达到全局最优；具有最优子结构性质：一个问题的最优解包含其子问题的最优解
>
> 
>
> 
>
> # 动态规划
>
> 动态规划拆分==子问题==，==记住==过往。一般来说可以用暴力递归，自顶向下的备忘录递归，自底向上的备忘录动态规划，后者可以减少重复计算。
>
> 动态规划有几个典型特征，**最优子结构：状态转移方程、边界 | 重叠不独立子问题**
>
> > 对比贪心？
> >
> > 贪心算法中作出的每步贪心决策都无法改变，因为贪心策略是由上一步的最优解推导下一步的最优解，而上一部之前的最优解则不作保留，贪心算法每一步的最优解一定包含上一步的最优解。
> >
> > 动态规划算法中全局最优解中一定包含某个局部最优解，但不一定包含前一个局部最优解，因此需要记录之前的所有最优解
>
> 
>
> 
>
> # 分支限界
>





# 回溯

### 应用与模板



# 分治与递归

### 应用与模板



# 贪心

### 应用与模板



# 动态规划

### 应用与模板



# 分支限界

### 应用与模板





# 其他模板

### 二分法

#### 无重复插入

```C++
int binarySearch(vector<int>& nums, int target) {
    int middle,left=0,right=nums.size()-1;
    while(left<=right){
        middle = left+(right-left)/2;
        if(nums[middle]<target) left=middle+1 ;
        else if(nums[middle]>target) right=middle-1;
        else return middle;
    }
    return left/right+1;
}
```

#### 区间查找

```C++
//使得区间在[left,right]区间内，单独探讨边界是否正常，注意while不包括left==right的情况以防死循环
//利用二分法最终归于某个元素的核对这一性质
int findLeft(vector<int>& nums, int target){
    int middle,left=0,right=nums.size()-1;
    while(left<right){
        middle=(left+right)/2;
        if(nums[middle]<target) left=middle+1;
        else if(nums[middle]>target) right=middle-1;
        else right=middle;
    }
    if(nums[left]==target) return left;
    else return -1;
}
int findRight(vector<int>& nums, int target){
    int middle,left=0,right=nums.size()-1;
    while(left<right){
        middle=(left+right)/2+(left+right)%2;
        if(nums[middle]<target) left=middle+1;
        else if(nums[middle]>target) right=middle-1;
        else left=middle;
    }
    if(nums[right]==target) return right;
    else return -1;
}
--------------------------------------merge--------------------------------------
//lower为true分nums[mid]>=target和nums[mid]<target,为false分nums[mid]<=target和nums[mid]>target
int binarySearch(vector<int>& nums,int target,bool lower){
    int left=0,right=nums.size()-1, ans=nums.size();
    while (left <= right){
        int mid=(left+right)/2;
        if (nums[mid]>target||(lower&&nums[mid]>=target)){
            right=mid-1;
            ans=mid;
        }
        else left=mid+1;        
    }
    return ans;
}
int leftIdx=binarySearch(nums,target,true);
int rightIdx=binarySearch(nums,target,false) - 1;
```



### 双指针

#### 快慢指针

```C++
int slowFast(vector<int>& nums, int val) {
    int slow=0;
    for(int fast=0;fast<nums.size();fast++){
        if(condition(nums[fast],val))
            action(slow++,fast);
    }
    return slow;
}
```

#### 双头指针

```C++
int leftRight(vector<int>& nums){
    int left=0,right=nums.size()-1;
    while(left<=right){
        if(condition(left,right)) select(left++,right--);
        else select(left++,right--);
    }
}
```

#### 滑动窗口

```C++
//先找到合法的窗口，再对窗口内进行优化
int startEnd(int target, vector<int>& nums) {
    int start=0;
    int res=INT32_MAX;
    for(int end=0;end<nums.size();end++){
        while(check(start,end,target)){
            for(start++)//for(start--)
            	deal(res，end-start+1);
        }
    }
    return res;
}
//unordered_map<char,int> ori,cnt合法检查与记录
unordered_map <char, int> ori, cnt;
bool check() {
    for (const auto &p: ori) {
        if (cnt[p.first] < p.second) {
            return false;
        }
    }
    return true;
}
for (const auto &c: t) {
    ++ori[c];
}
if (ori.find(s[end]) != ori.end()) {
    ++cnt[s[end]];
}
```



### 螺旋矩阵

```C++
vector<vector<int>> generateMatrix(int n) {
    vector<vector<int>> res(n,vector<int>(n,0));
    int x1=0,y1=0,x2=n-1,y2=n-1;
    int num=1;
    while(x1<x2&&y1<y2){
        for(int i=y1;i<y2;i++) res[x1][i]=num++;
        for(int i=x1;i<x2;i++) res[i][y2]=num++;
        for(int i=y2;i>y1;i--) res[x2][i]=num++;
        for(int i=x2;i>x1;i--) res[i][y1]=num++;
        x1++;y1++;x2--;y2--;
    }
    if(x1==x2)
        for(int i=y1;i<=y2;i++) res[x1][i]=num++;
    else if(y1==y2)
        for(int i=x1;i<=x2;i++) res[i][y1]=num++;
    return res;
}
```



### 链表

> 注意虚拟节点dummyHead

#### 定义

```C++
//合法检查，执行操作，修改属性
// 定义链表节点结构体
struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};
// 初始化链表  int _size = 0;
LinkedNode* _dummyHead= new LinkedNode(0,head);
LinkedNode* cur = _dummyHead->next;  //_dummyHead;
while(index--){   //while(cur->next != nullptr)
    cur = cur->next;
}
```

#### 反转链表

```C++
//遍历
ListNode* reverseList(ListNode* head) {
    ListNode *tmp;
    ListNode *curr=head;
    ListNode *pre=NULL;
    while(curr!=NULL){
        tmp=curr->next;
        curr->next=pre;
        pre=curr;
        curr=tmp;
    }
    return pre;
}
//递归：记录尾节点，逆向反转
ListNode* reverseList(ListNode* head) {
    if(head==NULL || head->next==NULL) return head;
    ListNode *last=reverseList(head->next);
    head->next->next=head;
    head->next=NULL;
    return last;
}
```



### 字符串

#### 字符串反转

```C++
void reverse(vector<char>& s,int start,int end){
    for(int i=start;i<=(start+end)/2;i++){
        swap(s[i],s[end+start-i]);
    }
}
----------------swap--------------------------------
int temp = s[i];
s[i] = s[j];
s[j] = temp;

a[i] = a[i] ^ a[j]; 
a[j] = a[i] ^ a[j]; // a[j] = a[i] ^ a[j] ^ a[j] = a[i]
a[i] = a[i] ^ a[j]; // a[i] = a[i] ^ a[j] ^ a[i] = a[j]

a[i] = a[i] + a[j];
a[j] = a[i] - a[j]; // a[j] = a[i] + a[j] - a[j]
a[i] = a[i] - a[j]; // a[i] = a[i] + a[j] - a[i]
```

#### 朴素模式匹配

```C++
int i=0,m=mainString.size(),n=modelString.size();
while(i+n<=m){
    if(modelString.compare(m.substr(i,n))!=0) ++i;
    else return i;
}
return 0;

int i=0,j=0;
while(i<m && j<n){
    if(mainString[i]==modelString[j]){
        ++i;
        ++j;
    }else{
        j=1;
        i-=j-2;
    }
    if(j>=n) return i-n;
    else return 0;
}
```

#### KMP

```C++

```



### 哈希表

>  数组计数器、集合存在问题、无限循环讨论、字典

| 集合               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
| ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |
| std::set           | 红黑树   | 有序     | 否               | 否           | O(log n) | O(log n) |
| std::multiset      | 红黑树   | 有序     | 是               | 否           | O(logn)  | O(logn)  |
| std::unordered_set | 哈希表   | 无序     | 否               | 否           | O(1)     | O(1)     |

| 映射               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
| ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |
| std::map           | 红黑树   | key有序  | key不可重复      | key不可修改  | O(logn)  | O(logn)  |
| std::multimap      | 红黑树   | key有序  | key可重复        | key不可修改  | O(log n) | O(log n) |
| std::unordered_map | 哈希表   | key无序  | key不可重复      | key不可修改  | O(1)     | O(1)     |
